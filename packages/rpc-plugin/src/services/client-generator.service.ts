import fs from 'fs/promises'
import path from 'path'
import type { ControllerGroups, ExtendedRouteInfo, RouteParameter } from '../types/route.types'
import type { GeneratedClientInfo, SchemaInfo } from '../types/schema.types'
import { buildFullApiPath } from '../utils/path-utils'
import { camelCase, safeToString } from '../utils/string-utils'

/**
 * Service for generating TypeScript RPC clients
 */
export class ClientGeneratorService {
	constructor(private readonly outputDir: string) {}

	/**
	 * Generates the TypeScript RPC client
	 */
	async generateClient(
		routes: readonly ExtendedRouteInfo[],
		schemas: readonly SchemaInfo[]
	): Promise<GeneratedClientInfo> {
		await fs.mkdir(this.outputDir, { recursive: true })

		await this.generateClientFile(routes, schemas)

		const generatedInfo: GeneratedClientInfo = {
			clientFile: path.join(this.outputDir, 'client.ts'),
			generatedAt: new Date().toISOString()
		}

		return generatedInfo
	}

	/**
	 * Generates the main client file with types included
	 */
	private async generateClientFile(
		routes: readonly ExtendedRouteInfo[],
		schemas: readonly SchemaInfo[]
	): Promise<void> {
		const clientContent = this.generateClientContent(routes, schemas)
		const clientPath = path.join(this.outputDir, 'client.ts')
		await fs.writeFile(clientPath, clientContent, 'utf-8')
	}

	/**
	 * Generates the client TypeScript content with types included
	 */
	private generateClientContent(routes: readonly ExtendedRouteInfo[], schemas: readonly SchemaInfo[]): string {
		const controllerGroups = this.groupRoutesByController(routes)

		return `// ============================================================================
// TYPES SECTION
// ============================================================================

/**
 * API Response wrapper
 */
export interface ApiResponse<T = any> {
	data: T
	message?: string
	success: boolean
}

/**
 * API Error class
 */
export class ApiError extends Error {
	constructor(
		public statusCode: number,
		message: string
	) {
		super(message)
		this.name = 'ApiError'
	}
}

/**
 * Clean separation of concerns for request options
 */
export type RequestOptions<
	TParams = undefined,
	TQuery = undefined,
	TBody = undefined,
	THeaders = undefined
> = (TParams extends undefined ? object : { params: TParams }) &
	(TQuery extends undefined ? object : { query: TQuery }) &
	(TBody extends undefined ? object : { body: TBody }) &
	(THeaders extends undefined ? object : { headers: THeaders })

/**
 * Custom fetch function type that matches the standard fetch API
 */
export type FetchFunction = (
	input: RequestInfo | URL,
	init?: RequestInit
) => Promise<Response>

// Generated DTOs and types from integrated Schema Generation
${this.generateSchemaTypes(schemas)}

// ============================================================================
// CLIENT SECTION
// ============================================================================

/**
 * Generated RPC Client
 * 
 * This class provides a type-safe HTTP client for interacting with your API endpoints.
 * It's automatically generated by the RPCPlugin based on your controller definitions.
 * 
 * @example
 * \`\`\`typescript
 * const apiClient = new ApiClient('http://localhost:3000')
 * 
 * // Make a request to get users
 * const response = await apiClient.users.getUsers()
 * 
 * // Make a request with parameters
 * const user = await apiClient.users.getUser({ params: { id: '123' } })
 * 
 * // Make a request with body data
 * const newUser = await apiClient.users.createUser({ 
 *   body: { name: 'John', email: 'john@example.com' } 
 * })
 * 
 * // Use with custom fetch function (e.g., for testing or custom logic)
 * const customFetch = (input: RequestInfo | URL, init?: RequestInit) => {
 *   console.log('Making request to:', input)
 *   return fetch(input, init)
 * }
 * 
 * const apiClientWithCustomFetch = new ApiClient('http://localhost:3000', {
 *   fetchFn: customFetch,
 *   defaultHeaders: { 'X-Custom-Header': 'value' }
 * })
 * \`\`\`
 * 
 * @generated This class is auto-generated by RPCPlugin
 */
export class ApiClient {
	private baseUrl: string
	private defaultHeaders: Record<string, string>
	private fetchFn: FetchFunction

	constructor(
		baseUrl: string, 
		options: {
			defaultHeaders?: Record<string, string>
			fetchFn?: FetchFunction
		} = {}
	) {
		this.baseUrl = baseUrl.replace(/\\/$/, '')
		this.defaultHeaders = {
			'Content-Type': 'application/json',
			...options.defaultHeaders
		}
		this.fetchFn = options.fetchFn || fetch
	}

	/**
	 * Set default headers for all requests
	 */
	setDefaultHeaders(headers: Record<string, string>): this {
		this.defaultHeaders = { ...this.defaultHeaders, ...headers }
		return this
	}


	/**
	 * Make an HTTP request with flexible options
	 */
	private async request<T>(
		method: string,
		path: string,
		options: RequestOptions<any, any, any, any> = {}
	): Promise<ApiResponse<T>> {
		const { params, query, body, headers = {} } = options as any
		
		// Build the final URL with path parameters
		let finalPath = path
		if (params) {
			Object.entries(params).forEach(([key, value]) => {
				finalPath = finalPath.replace(\`:\${key}\`, String(value))
			})
		}

		const url = new URL(finalPath, this.baseUrl)
		
		// Add query parameters
		if (query) {
			Object.entries(query).forEach(([key, value]) => {
				if (value !== undefined && value !== null) {
					url.searchParams.append(key, String(value))
				}
			})
		}

		// Merge default headers with request-specific headers
		const finalHeaders = { ...this.defaultHeaders, ...headers }

		const requestOptions: RequestInit = {
			method,
			headers: finalHeaders,
		}

		if (body && method !== 'GET') {
			requestOptions.body = JSON.stringify(body)
		}

		try {
			const response = await this.fetchFn(url.toString(), requestOptions)
			const responseData = await response.json()

			if (!response.ok) {
				throw new ApiError(response.status, responseData.message || 'Request failed')
			}

			return responseData
		} catch (error) {
			if (error instanceof ApiError) {
				throw error
			}
			throw new ApiError(0, error instanceof Error ? error.message : 'Network error')
		}
	}

${this.generateControllerMethods(controllerGroups)}
}
`
	}

	/**
	 * Generates controller methods for the client
	 */
	private generateControllerMethods(controllerGroups: ControllerGroups): string {
		let methods = ''

		for (const [controllerName, routes] of controllerGroups) {
			const className = controllerName.replace(/Controller$/, '')
			methods += `
	// ${className} Controller
`
			methods += `	get ${camelCase(className)}() {
`
			methods += `		return {
`

			for (const route of routes) {
				const methodName = camelCase(safeToString(route.handler))
				const httpMethod = safeToString(route.method).toLowerCase()
				const { pathParams, queryParams, bodyParams } = this.analyzeRouteParameters(route)

				const hasRequiredParams =
					pathParams.length > 0 ||
					queryParams.some((p) => p.required) ||
					(bodyParams.length > 0 && httpMethod !== 'get')

				// Generate the method signature with proper typing
				methods += `			${methodName}: async (options${hasRequiredParams ? '' : '?'}: RequestOptions<`

				// Path parameters type
				if (pathParams.length > 0) {
					const pathParamTypes = pathParams.map((p) => {
						const paramName = p.name
						const paramType = p.type || 'any'
						return `${paramName}: ${paramType}`
					})
					methods += `{ ${pathParamTypes.join(', ')} }`
				} else {
					methods += 'undefined'
				}

				methods += ', '

				// Query parameters type
				if (queryParams.length > 0) {
					const queryParamTypes = queryParams.map((p) => {
						const paramName = p.name
						const paramType = p.type || 'any'
						return `${paramName}: ${paramType}`
					})
					methods += `{ ${queryParamTypes.join(', ')} }`
				} else {
					methods += 'undefined'
				}

				methods += ', '

				// Body type
				if (bodyParams.length > 0) {
					const bodyParamTypes = bodyParams.map((p) => {
						const paramType = p.type || 'any'
						return paramType
					})
					// Use the first body parameter type, not 'any'
					methods += bodyParamTypes[0] || 'any'
				} else {
					methods += 'undefined'
				}

				methods += ', '

				// Headers type - always optional for now, but could be made conditional
				methods += 'undefined'

				// Extract return type from route analysis for better type safety
				const returnType = this.extractReturnType(route.returns)
				methods += `>): Promise<ApiResponse<${returnType}>> => {
`

				// Build the full API path using route information
				let requestPath = buildFullApiPath(route)

				// Replace path parameters with placeholders for dynamic substitution
				if (pathParams.length > 0) {
					for (const pathParam of pathParams) {
						const paramName = pathParam.name
						const placeholder = `:${String(pathParam.data)}`
						requestPath = requestPath.replace(placeholder, `:${paramName}`)
					}
				}

				methods += `				return this.request<${returnType}>('${httpMethod.toUpperCase()}', \`${requestPath}\`, options)
`
				methods += `			},
`
			}

			methods += `		}
`
			methods += `	}
`
		}

		return methods
	}

	/**
	 * Extracts the proper return type from route analysis
	 */
	private extractReturnType(returns?: string): string {
		if (!returns) return 'any'

		// Handle Promise<T> types
		const promiseMatch = returns.match(/Promise<(.+)>/)
		if (promiseMatch) {
			return promiseMatch[1]
		}

		// Handle other types
		return returns
	}

	/**
	 * Generates schema types from integrated schema generation
	 */
	private generateSchemaTypes(schemas: readonly SchemaInfo[]): string {
		if (schemas.length === 0) {
			return '// No schemas available from integrated Schema Generation\n'
		}

		let content = '// Schema types from integrated Schema Generation\n'
		for (const schemaInfo of schemas) {
			if (schemaInfo.typescriptType) {
				content += `${schemaInfo.typescriptType}\n\n`
			}
		}
		return content
	}

	/**
	 * Groups routes by controller for better organization
	 */
	private groupRoutesByController(routes: readonly ExtendedRouteInfo[]): ControllerGroups {
		const groups = new Map<string, ExtendedRouteInfo[]>()

		for (const route of routes) {
			const controller = safeToString(route.controller)
			if (!groups.has(controller)) {
				groups.set(controller, [])
			}
			groups.get(controller)!.push(route)
		}

		return groups
	}

	/**
	 * Analyzes route parameters to determine their types and usage
	 */
	private analyzeRouteParameters(route: ExtendedRouteInfo): {
		pathParams: readonly RouteParameter[]
		queryParams: readonly RouteParameter[]
		bodyParams: readonly RouteParameter[]
	} {
		const parameters = route.parameters || []
		const method = String(route.method || '').toLowerCase()

		const isInPath = (p: RouteParameter): boolean => {
			// Check if this parameter corresponds to a path segment
			// For path parameters, the data field should contain the path segment name
			const pathSegment = p.data
			return !!pathSegment && typeof pathSegment === 'string' && route.path.includes(`:${pathSegment}`)
		}

		// path params are always required if they exist in the path
		const pathParams = parameters.filter((p) => isInPath(p)).map((p) => ({ ...p, required: true }))

		// body is required if any body param exists for non-GET
		const rawBody = parameters.filter((p) => !isInPath(p) && method !== 'get')
		const bodyParams = rawBody.map((p) => ({
			...p,
			required: true
		}))

		// query requiredness comes from analyzer if available; default optional
		const queryParams = parameters
			.filter((p) => !isInPath(p) && method === 'get')
			.map((p) => ({
				...p,
				required: p.required === true // default false if not provided
			}))

		return { pathParams, queryParams, bodyParams }
	}
}
